Содержание
1 ВВЕДЕНИЕ 4
1.1 1.2 Цель работы . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
Задачи работы . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2 АНАЛИЗ ПРЕДМЕТНОЙ ОБЛАСТИ 4
2.1 2.2 2.3 Постановка задачи . . . . . . . . . . . . . . . . . . . . . . . . 4
Концептуальная модель . . . . . . . . . . . . . . . . . . . . . 5
Функциональные требования . . . . . . . . . . . . . . . . . . 5
3 АНАЛИЗ МЕТОДОВ ХРАНЕНИЯ ДАННЫХ И АЛГО-
РИТМОВ 5
3.1 Методы хранения данных . . . . . . . . . . . . . . . . . . . . 5
3.1.1 Линейный односвязный список . . . . . . . . . . . . . 6
3.1.2 Двусвязный список . . . . . . . . . . . . . . . . . . . 6
3.1.3 Динамический массив (вектор) . . . . . . . . . . . . . 6
3.1.4 Хэш-таблица . . . . . . . . . . . . . . . . . . . . . . . 6
3.2 Методы сортировки . . . . . . . . . . . . . . . . . . . . . . . 7
3.2.1 Пузырьковая сортировка . . . . . . . . . . . . . . . . 7
3.2.2 Сортировка выбором . . . . . . . . . . . . . . . . . . 7
3.2.3 Быстрая сортировка (QuickSort) . . . . . . . . . . . . 7
3.2.4 Сортировка слиянием (MergeSort) . . . . . . . . . . . 7
3.3 Методы поиска . . . . . . . . . . . . . . . . . . . . . . . . . . 7
3.3.1 Линейный поиск . . . . . . . . . . . . . . . . . . . . . 7
3.3.2 Бинарный поиск . . . . . . . . . . . . . . . . . . . . . 8
3.3.3 Поиск в хэш-таблице . . . . . . . . . . . . . . . . . . 8
4 ТЕХНИЧЕСКОЕ ЗАДАНИЕ 8
4.1 Язык программирования и среда разработки . . . . . . . . . 8
4.2 4.3 Функциональные требования . . . . . . . . . . . . . . . . . . 8
Нефункциональные требования . . . . . . . . . . . . . . . . 8
5 РАЗРАБОТКА И АНАЛИЗ ТРЕБОВАНИЙ 9
5.1 Требования к пользовательскому интерфейсу . . . . . . . . 9
5.1.1 Сценарии использования . . . . . . . . . . . . . . . . 9
1
5.1.2 Макеты пользовательского интерфейса . . . . . . . . 12
5.2 Требованиякпрограммномуинтерфейсуииспользуемымре-
сурсам . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5.2.1 Программный интерфейс . . . . . . . . . . . . . . . . 5.2.2 Системные требования . . . . . . . . . . . . . . . . . 5.2.3 Интеграционные возможности . . . . . . . . . . . . . 5.2.4 Ограничения . . . . . . . . . . . . . . . . . . . . . . . 13
13
13
13
14
6 ПРОЕКТИРОВАНИЕ СТРУКТУРЫ ПРОГРАММЫ 14
6.1 Архитектура программного обеспечения . . . . . . . . . . . 14
6.1.1 Основные модули системы . . . . . . . . . . . . . . . 14
6.2 Структура данных . . . . . . . . . . . . . . . . . . . . . . . . 15
6.2.1 Описание основного объекта программы . . . . . . . 15
6.2.2 Структура для хранения коллекции заметок . . . . . 16
6.3 6.4 Словарь данных . . . . . . . . . . . . . . . . . . . . . . . . . 16
Описание файлов . . . . . . . . . . . . . . . . . . . . . . . . . 16
6.4.1 Файл метаданных notes_metadata.dat . . . . . . . . . 16
6.4.2 Текстовые файлы заметок . . . . . . . . . . . . . . . 17
6.5 Алгоритмы работы системы . . . . . . . . . . . . . . . . . . 18
6.5.1 Алгоритм добавления новой заметки . . . . . . . . . 18
6.5.2 Алгоритм поиска заметок по теме . . . . . . . . . . . 18
6.5.3 Алгоритм удаления заметки . . . . . . . . . . . . . . 18
6.6 6.7 Взаимодействие модулей . . . . . . . . . . . . . . . . . . . . 19
Обработка ошибок . . . . . . . . . . . . . . . . . . . . . . . . 19
7 РАЗРАБОТКА И ОТЛАДКА ПРОГРАММЫ 20
7.1 Конвенции именования и стиль оформления кода . . . . . . 20
7.1.1 Конвенции именования . . . . . . . . . . . . . . . . . 20
7.1.2 Стиль оформления кода . . . . . . . . . . . . . . . . . 20
7.2 Описание разработанных модулей и функций . . . . . . . . . 21
7.3 Описание разработанных модулей и функций . . . . . . . . . 21
7.4 7.5 Структура проекта . . . . . . . . . . . . . . . . . . . . . . . . 25
Реализация ключевых алгоритмов . . . . . . . . . . . . . . . 26
7.5.1 Алгоритм загрузки данных . . . . . . . . . . . . . . . 26
7.5.2 Алгоритм поиска по теме . . . . . . . . . . . . . . . . 26
2
7.6 7.7 7.8 7.5.3 Алгоритм валидации ввода . . . . . . . . . . . . . . . Использованные приемы оптимизации . . . . . . . . . . . . . 7.6.1 Оптимизация производительности . . . . . . . . . . . 7.6.2 Оптимизация объема кода . . . . . . . . . . . . . . . Использованные средства отладки . . . . . . . . . . . . . . . 7.7.1 Средства компилятора . . . . . . . . . . . . . . . . . 7.7.2 Техники отладки . . . . . . . . . . . . . . . . . . . . . 7.7.3 Обработка ошибок . . . . . . . . . . . . . . . . . . . . Особенности реализации . . . . . . . . . . . . . . . . . . . . . 7.8.1 Обработка исключительных ситуаций . . . . . . . . . 7.8.2 Кроссплатформенность . . . . . . . . . . . . . . . . . 7.8.3 Безопасность . . . . . . . . . . . . . . . . . . . . . . . 27
28
28
28
28
28
28
29
29
29
30
30
3
1 ВВЕДЕНИЕ
1.1 Цель работы
Целью данной работы является разработка консольного приложения на
языке C++ для управления персональными текстовыми заметками с воз-
можностью их создания, поиска, фильтрации и просмотра.
1.2 Задачи работы
1. Проанализировать предметную область «Система управления замет-
ками»
2. Разработать архитектуру системы
3. Реализовать функции создания, удаления и редактирования заметок
4. Организовать эффективное хранение данных
5. Реализовать механизмы поиска и фильтрации
6. Обеспечить обработку ошибок и пользовательский интерфейс
2 АНАЛИЗ ПРЕДМЕТНОЙ ОБЛАСТИ
2.1 Постановка задачи
Разработать программу «Система управления заметками», которая долж-
на предоставлять пользователю возможность создания, хранения, поиска
и управления текстовыми заметками.
Каждая заметка должна сохраняться в виде текстового файла и со-
держать следующие атрибуты:
• Название
• Тема
• Дата создания
• Текст заметки
Программа должна обеспечивать:
• Добавление и удаление заметок
• Вывод списка всех заметок с возможностью фильтрации по дате или
теме
4
• Открытие и отображение текста выбранной заметки
• Хранение метаданных заметок в структурированном виде для эф-
фективного доступа
2.2 Концептуальная модель
Основная сущность — Заметка (NOTE). Её атрибуты:
• Название(Title):Строковыйатрибут,уникальныйидентификаторза-
метки
• Тема (Category): Строковый атрибут, определяет тематику заметки
• Дата создания (Creation Date): Автоматически устанавливается при
создании заметки
• Текст заметки (Content): Основное содержимое заметки
• Путь к файлу (File Path): Полный путь к файлу заметки на диске
2.3 Функциональные требования
1. Добавление заметки: Пользователь вводит название, тему, текст.
Программа создаёт текстовый файл в указанной директории, сохра-
няет метаданные
2. Удаление заметки: Удаляется файл заметки и соответствующая
запись в каталоге
3. Поиск и фильтрация: Возможен вывод списка заметок по дате или
по теме
4. Открытие заметки: Программа считывает и выводит содержимое
текстового файла
5. Целостностьданных:Проверкауникальностиназвания,обработка
ошибок доступа к файлам
3 АНАЛИЗ МЕТОДОВ ХРАНЕНИЯ ДАННЫХ И
АЛГОРИТМОВ
3.1 Методы хранения данных
Дляхраненияметаданныхзаметокмогутиспользоватьсяследующиеструк-
туры данных:
5
3.1.1 Линейный односвязный список
Преимущества:
• Простота реализации
• Эффективное добавление и удаление элементов
• Динамическое изменение размера
Недостатки:
• Медленный доступ к произвольному элементу (O(n))
• Неэффективен для частого поиска
3.1.2 Двусвязный список
Преимущества:
• Возможность обхода в обе стороны
• Удобство удаления элементов
Недостатки:
• Больший расход памяти на хранение ссылок
• Сложность реализации по сравнению с односвязным списком
3.1.3 Динамический массив (вектор)
Преимущества:
• Быстрый доступ по индексу (O(1))
• Эффективное использование кэша процессора
Недостатки:
• Медленное добавление/удаление в середине (O(n))
• Возможность избыточного выделения памяти
3.1.4 Хэш-таблица
Преимущества:
• Быстрый поиск по ключу (O(1) в среднем случае)
• Эффективна для частых операций поиска
6
Недостатки:
• Затраты по памяти
• Сложность реализации
• Неупорядоченность данных
3.2 Методы сортировки
3.2.1 Пузырьковая сортировка
• Сложность: O(n²)
• Простота реализации
• Стабильность
3.2.2 Сортировка выбором
• Сложность: O(n²)
• Простота реализации
• Нестабильность
3.2.3 Быстрая сортировка (QuickSort)
• Сложность: O(n log n) в среднем случае
• Высокая производительность
• Нестабильность
3.2.4 Сортировка слиянием (MergeSort)
• Сложность: O(n log n)
• Стабильность
• Требует дополнительной памяти
3.3 Методы поиска
3.3.1 Линейный поиск
• Сложность: O(n)
• Подходит для неупорядоченных данных
• Простота реализации
7
3.3.2 Бинарный поиск
• Сложность: O(log n)
• Требует отсортированных данных
• Эффективен для частого поиска
3.3.3 Поиск в хэш-таблице
• Сложность: O(1) в среднем случае
• Максимальная скорость поиска
• Требует дополнительной памяти
4.1 4 ТЕХНИЧЕСКОЕ ЗАДАНИЕ
Язык программирования и среда разработки
• Язык программирования: C++
• Стандарт: C++17
• Среда разработки: Visual Studio Code / Visual Studio
• Компилятор: GCC / MSVC
4.2 Функциональные требования
1. Создание новой заметки с указанием названия, темы и текста
2. Удаление существующей заметки
3. Просмотр списка всех заметок
4. Фильтрация заметок по теме
5. Сортировка заметок по дате создания
6. Просмотр содержимого выбранной заметки
7. Сохранение данных между сеансами работы
4.3 Нефункциональные требования
• Время отклика системы: не более 1 секунды
• Поддержка до 1000 заметок
• Кроссплатформенность (Windows/Linux)
• Простота использования
• Обработка ошибочных ситуаций
8
5 РАЗРАБОТКА И АНАЛИЗ ТРЕБОВАНИЙ
5.1 Требования к пользовательскому интерфейсу
5.1.1 Сценарии использования
Сценарий UC_1: Запуск приложения
• Идентификатор сценария: UC_1
• Предусловия: Имеется исполняющий файл приложения
• Действующие лица: Пользователь, операционная система
• Цель: Запуск консольного приложения
• Успешный сценарий:
1. Пользователь запускает приложение
2. На экране отображается пронумерованный список пунктов ме-
ню и предложение ввести номер одного из пунктов
3. Пользователь вводит номер пункта меню
• Результат: Начало работы приложения
Сценарий UC_2: Добавление новой заметки
• Идентификатор сценария: UC_2
• Предусловия: Приложение корректно запущено в соответствии со
сценарием UC_1
• Действующие лица: Пользователь, система хранения данных
• Цель: Добавить новую текстовую заметку в систему
• Успешный сценарий:
1. Пользователь вводит номер пункта меню "Создать заметку"
2. На экране отображается предложение ввести название заметки
3. Пользователь вводит название заметки и нажимает Enter
4. Приложение выводит сообщение с предложением ввести тему
заметки
5. Пользователь вводит тему заметки и нажимает Enter
6. Приложение выводит сообщение с предложением ввести текст
заметки
7. Пользователь вводит текст заметки и нажимает Enter
8. Приложение сохраняет заметку и выводит сообщение об успеш-
9
ном создании
• Результат: Новая заметка успешно добавлена в систему
• Возможные варианты неуспешного выполнения:
3a. Если пользователь ввел название, которое уже существует, при-
ложение выводит сообщение об ошибке и предлагает повторить
ввод
5a. Если пользователь ввел пустую тему, приложение выводит со-
общение об ошибке и предлагает повторить ввод
Сценарий UC_3: Просмотр списка всех заметок
• Идентификатор сценария: UC_3
• Предусловия: Приложение корректно запущено
• Действующие лица: Пользователь, система хранения данных
• Цель: Просмотреть список всех сохраненных заметок
• Успешный сценарий:
1. Пользователь вводит номер пункта меню "Показать все замет-
ки"
2. Приложение выводит таблицу со списком всех заметок, содер-
жащую колонки: номер, название, тема, дата создания
3. Пользователь просматривает список заметок
• Результат: Отображен полный список заметок
• Возможные варианты неуспешного выполнения:
2a. Если в системе нет заметок, приложение выводит сообщение
"Заметки не найдены"и возвращает в главное меню
Сценарий UC_4: Поиск заметок по теме
• Идентификатор сценария: UC_4
• Предусловия: Приложение корректно запущено
• Действующие лица: Пользователь, система хранения данных
• Цель: Найти заметки по заданной теме
• Успешный сценарий:
1. Пользователь вводит номер пункта меню "Поиск по теме"
2. Приложение выводит предложение ввести тему для поиска
3. Пользователь вводит тему и нажимает Enter
4. Приложение выводит таблицу с заметками указанной темы
10
• Результат: Отображены заметки заданной темы
• Возможные варианты неуспешного выполнения:
4a. Если заметки с указанной темой не найдены, приложение вы-
водит сообщение "Заметки не найдены"и предлагает повторить
поиск
Сценарий UC_5: Просмотр содержимого заметки
• Идентификатор сценария: UC_5
• Предусловия: Приложение корректно запущено, отображен список
заметок
• Действующие лица: Пользователь, система хранения данных
• Цель: Просмотреть полное содержимое выбранной заметки
• Успешный сценарий:
1. Пользователь вводит номер пункта меню "Открыть заметку"
2. Приложение выводит предложение ввести номер заметки
3. Пользователь вводит номер заметки и нажимает Enter
4. Приложениевыводитполноесодержимоезаметки:название,те-
му, дату создания, текст
• Результат: Отображено полное содержимое заметки
• Возможные варианты неуспешного выполнения:
3a. Если введен несуществующий номер заметки, приложение вы-
водит сообщение об ошибке и предлагает повторить ввод
Сценарий UC_6: Удаление заметки
• Идентификатор сценария: UC_6
• Предусловия: Приложение корректно запущено
• Действующие лица: Пользователь, система хранения данных
• Цель: Удалить выбранную заметку из системы
• Успешный сценарий:
1. Пользователь вводит номер пункта меню "Удалить заметку"
2. Приложение выводит предложение ввести номер заметки для
удаления
3. Пользователь вводит номер заметки и нажимает Enter
4. Приложение запрашивает подтверждение удаления
5. Пользователь подтверждает удаление
11
6. Приложение удаляет заметку и выводит сообщение об успеш-
ном удалении
• Результат: Заметка удалена из системы
• Возможные варианты неуспешного выполнения:
3a. Если введен несуществующий номер заметки, приложение вы-
водит сообщение об ошибке и предлагает повторить ввод
5a. Если пользователь отменяет удаление, приложение возвращает
в главное меню
5.1.2 Макеты пользовательского интерфейса
Главное меню программы:
=== СИСТЕМА УПРАВЛЕНИЯ ЗАМЕТКАМИ ===
1. Создать новую заметку
2. Показать все заметки
3. Поиск по теме
4. Открыть заметку
5. Удалить заметку
6. Выход
Выберите пункт меню: _
Макет таблицы вывода заметок:
=== СПИСОК ЗАМЕТОК ===
№ Название Тема Дата создания
-- ---------------- ---------- ----------------
1 Покупки Список 2024-01-15
2 Идеи проекта Работа 2024-01-16
3 Рецепт Кулинария 2024-01-17
Макет просмотра содержимого заметки:
=== ЗАМЕТКА #1 ===
12
Название: Покупки
Тема: Список
Дата: 2024-01-15
Текст:
- Молоко
- Хлеб
- Яйца
- Фрукты
5.2 Требования к программному интерфейсу и используемым
ресурсам
5.2.1 Программный интерфейс
• Операционная система: Windows 10/11, Linux (совместимые дис-
трибутивы)
• Стандарт языка: C++17
• Внешние библиотеки: Стандартная библиотека C++ (STL)
• Файловая система: Работа с текстовыми файлами через стандарт-
ные средства ввода-вывода
5.2.2 Системные требования
• Процессор: x86/x64 с поддержкой стандарта C++17
• Оперативная память: Не менее 512 МБ
• Дисковое пространство:Не менее 10 МБ для исполняемого файла
и данных
• Дополнительное оборудование: Клавиатура для ввода данных
5.2.3 Интеграционные возможности
• Файловый ввод-вывод: Сохранение данных в текстовых файлах с
возможностью ручного редактирования
• Формат данных: Текстовые файлы в кодировке UTF-8
• ВзаимодействиесОС:Использованиестандартныхпотоковввода-
вывода консоли
13
Рис. 1: Архитектура системы управления заметками
5.2.4 Ограничения
• Программанетребуетустановкидополнительногопрограммногообес-
печения
• Не требует прав администратора для работы
• Работает в автономном режиме без сетевых соединений
• Поддерживает хранение до 1000 заметок (ограничение может быть
изменено в настройках компиляции)
6 ПРОЕКТИРОВАНИЕ СТРУКТУРЫ ПРОГРАММЫ
6.1 Архитектура программного обеспечения
На основе анализа требований и предметной области разработана модуль-
ная архитектура системы управления заметками. Программа состоит из
следующих основных компонентов (рисунок 1):
6.1.1 Основные модули системы
1. Модуль пользовательского интерфейса (UI) - отвечает за вза-
имодействие с пользователем, отображение меню и обработку вводи-
мых команд
2. Модуль управления данными (Data Manager) - осуществляет
операции с заметками: создание, чтение, обновление, удаление
3. Модуль хранения данных (Storage) - обеспечивает сохранение и
загрузку данных в файловую систему
14
4. Модуль поиска и фильтрации (Search) - реализует алгоритмы
поиска заметок по различным критериям
5. Модуль валидации данных (Validation) - проверяет коррект-
ность вводимых пользователем данных
6.2 Структура данных
6.2.1 Описание основного объекта программы
Основной объект программы - структура Note, представляющая собой тек-
стовую заметку:
struct Note {
int id; // Уникальный идентификатор заметки
std::string title; // Название заметки
std::string category; // Тема/категория заметки
std::string content; // Текст заметки
std::string creationDate; // Дата создания в формате ГГГГ-ММ-ДД
std::string filePath; // Путь к файлу заметки
};
Описание полей структуры:
• id - целочисленный уникальный идентификатор. Используется тип
int, так как предполагается хранение до 1000 заметок. Автоматиче-
ски генерируется программой при создании новой заметки.
• title - название заметки. Тип данных: std::string. Ограничения:
длина от 1 до 100 символов, может содержать буквы русского и ла-
тинского алфавита, цифры, пробелы и знаки препинания.
• category-тема/категориязаметки.Типданных:std::string.Огра-
ничения: длина от 1 до 50 символов, допустимы буквы русского и
латинского алфавита.
• content - текст заметки. Тип данных: std::string. Ограничения:
максимальная длина 10000 символов, поддерживает многострочный
текст.
• creationDate - дата создания. Тип данных: std::string. Формат:
ГГГГ-ММ-ДД. Заполняется автоматически при создании заметки.
15
• filePath - путь к файлу. Тип данных: std::string. Содержит пол-
ный путь к текстовому файлу заметки на диске.
6.2.2 Структура для хранения коллекции заметок
Для хранения коллекции заметок используется std::vector<Note>:
class NoteManager {
private:
std::vector<Note> notes; // Коллекция заметок
int nextId; // Следующий доступный ID
// ... методы управления
};
Обоснование выбора std::vector:
• Быстрый доступ по индексу (O(1)) для операций отображения и от-
крытия заметок
• Эффективное использование кэша процессора
• Автоматическое управление памятью
• Поддержка стандартных алгоритмов STL для сортировки и поиска
6.3 Словарь данных
В таблице 1 представлен словарь данных, содержащий описание всех дан-
ных, запрашиваемых у пользователя, и соответствующих проверок.
6.4 Описание файлов
6.4.1 Файл метаданных notes_metadata.dat
Содержит информацию о всех заметках в системе. Структура файла:
<id>|<title>|<category>|<creation_date>|<file_path>
Пример содержимого:
1|Покупки|Список|2024-01-15|./notes/1_покупки.txt
2|Идеи проекта|Работа|2024-01-16|./notes/2_идеи_проекта.txt
3|Рецепт|Кулинария|2024-01-17|./notes/3_рецепт.txt
16
Таблица 1: Словарь данных
Наименование
Тип
переменной
данных
Семантика Проверки коррект-
ности ввода
menu_choice int Выбор пункта ме-
ню
Целое число от 1 до 6
note_title string Название заметки Длина от 1 до 100
символов, запрещены
специальные символы
кроме пробелов и де-
фисов
note_category string Тема заметки Длина от 1 до 50 сим-
волов, только буквы и
пробелы
note_content string Текст заметки Длина до 10000 сим-
волов, многострочный
ввод
search_categorystring Тема для поиска Длина от 1 до 50 сим-
волов, проверка суще-
ствования тем
note_id int Идентификатор
заметки
Целое число от 1 до
1000, проверка суще-
ствования ID
Описание полей:
• Разделитель полей: символ ’|’
• Кодировка: UTF-8
• Каждая запись занимает одну строку
• Файл автоматически сортируется по дате создания при сохранении
6.4.2 Текстовые файлы заметок
Каждая заметка сохраняется в отдельном текстовом файле с именем фор-
мата:
<id>_<название>.txt
Структура файла заметки:
Название: <title>
Тема: <category>
17
Дата: <creation_date>
<content>
6.5 Алгоритмы работы системы
6.5.1 Алгоритм добавления новой заметки
1. Получить от пользователя название, тему и текст заметки
2. Проверить уникальность названия
3. Сгенерировать уникальный ID
4. Создать структуру Note с текущей датой
5. Сохранить текстовый файл заметки
6. Добавить запись в файл метаданных
7. Обновить коллекцию в оперативной памяти
6.5.2 Алгоритм поиска заметок по теме
1. Получить тему для поиска от пользователя
2. Выполнить линейный поиск по коллекции заметок
3. Для каждой заметки сравнить поле category с искомым значением
4. Сформировать список найденных заметок
5. Отсортировать результаты по дате создания
6. Вывести результаты в табличном формате
6.5.3 Алгоритм удаления заметки
1. Получить ID заметки для удаления
2. Найти заметку в коллекции
3. Запросить подтверждение удаления
4. Удалить текстовый файл заметки
5. Удалить запись из файла метаданных
6. Удалить элемент из коллекции в памяти
7. Перенумеровать оставшиеся заметки при необходимости
18
Рис. 2: Взаимодействие модулей системы
6.6 Взаимодействие модулей
На рисунке 2 представлена диаграмма взаимодействия основных модулей
системы.
Основные потоки данных:
• Модуль UI передает команды модулю Data Manager
• Data Manager использует модуль Validation для проверки входных
данных
• Storage модуль обеспечивает сохранение/загрузку данных по запросу
Data Manager
• Модуль Search предоставляет функции поиска для Data Manager
• Все модули взаимодействуют через четко определенные интерфейсы
6.7 Обработка ошибок
Система предусматривает обработку следующих типов ошибок:
• Ошибки ввода пользователя (некорректные данные)
19
• Ошибки доступа к файлам (отсутствие прав, повреждение файлов)
• Ошибки памяти (недостаток оперативной памяти)
• Ошибки целостности данных (повреждение метаданных)
Для каждой ошибки предусмотрено информативное сообщение поль-
зователю и корректное восстановление работы системы.
7 РАЗРАБОТКА И ОТЛАДКА ПРОГРАММЫ
7.1 Конвенции именования и стиль оформления кода
В соответствии с принципами структурного программирования и рекомен-
дациями методического пособия, в проекте приняты следующие соглаше-
ния:
7.1.1 Конвенции именования
• Переменные: snake_case
std::string note_title;
int menu_choice;
std::vector<Note> notes_list;
• Функции: camelCase
void createNewNote();
void displayAllNotes();
bool validateInput();
• Классы и структуры: PascalCase
class NoteManager;
struct Note;
class FileHandler;
• Константы: UPPER_CASE
const int MAX_NOTES = 1000;
const std::string DATA_FILE = "notes_metadata.dat";
7.1.2 Стиль оформления кода
• Отступы: 4 пробела (без использования табуляции)
• Фигурные скобки: размещение на отдельной строке
20
if (condition)
{
// код
}
• Комментарии: подробное комментирование всех функций и слож-
ных блоков кода
• Длина строки: не более 80 символов
7.2 Описание разработанных модулей и функций
В таблице 2 представлены основные функции, разработанные в рамках
проекта.
7.3 Описание разработанных модулей и функций
В таблицах 2-4 представлены основные функции, разработанные в рамках
проекта.
21
Таблица 2: Функции инициализации и пользовательского интерфейса
№ Прототип
функции
Входные
параметры
Выходной
Описание функ-
пара-
метр
ционала
1 void
– – initializeSystem()
Инициализация
системы: загрузка
данных из файла,
проверка целост-
ности данных,
создание необходи-
мых директорий
2 void
displayMainMenu()
– – Отображение глав-
ного меню програм-
мы с нумерованным
списком доступных
операций
3 Note
– Note createNewNote()
Создание новой за-
метки: запрос дан-
ных у пользователя,
валидацияввода,ге-
нерация ID и даты
создания
4 bool
title - назва-
validateNoteTitle(const
ние заметки
std::string&
для проверки
title)
bool
(true -
коррект-
но, false -
ошибка)
Проверка коррект-
ности названия за-
метки: длина, до-
пустимые символы,
уникальность
5 bool
category -
validateNoteCategory(const
тема заметки
std::string&
для проверки
category)
bool
(true -
коррект-
но, false -
ошибка)
Проверка коррект-
ности темы замет-
ки: длина, допусти-
мые символы
22
Таблица 3: Функции работы с данными и файлами
№ Прототип
функции
Входные
параметры
Выходной
Описание функ-
пара-
метр
ционала
6 void
note - струк-
saveNoteToFile(const
турасданны-
Note& note)
ми заметки
– Сохранение заметки
в текстовый файл
с именем формата
"id_название.txt"
7 void
notes - вектор
updateMetadataFile(const
всех заметок
std::vector<Note>&
notes)
– Обновление файла
метаданных с ин-
формацией о всех
заметках системы
8 std::vector<Note>
– std::vector<Note> Загрузка всех за-
loadAllNotes()
меток из файла
метаданных и со-
ответствующих
текстовых файлов
9 void
notes - вектор
displayNotesList(const
заметок для
std::vector<Note>&
отображения
notes)
– Вывод списка за-
меток в табличном
формате с колонка-
ми:№,Название,Те-
ма, Дата
23
Таблица 4: Функции поиска, отображения и управления
№ Прототип
функции
Входные
параметры
Выходной
Описание функ-
пара-
метр
ционала
10 std::vector<Note>
notes - вектор
searchNotesByCategory(const
для поиска,
std::vector<Note>&
category -
notes, const
std::string&
category)
тема для
фильтрации
std::vector<Note> Поиск заметок по
заданной теме с
использованием
линейного поиска
11 void
note_id -
displayNoteContent(int
идентифика-
note_id)
тор заметки
– Отображение пол-
ного содержимого
выбранной заметки:
название, тема,
дата, текст
12 bool
note_id -
deleteNoteById(int
идентифика-
note_id)
тор заметки
для удаления
bool (ре-
зультат
опера-
ции)
Удаление заметки:
удаление фай-
ла, обновление
метаданных, пере-
строение коллекции
13 void
cleanupSystem()
– – Корректное за-
вершение работы:
сохранение данных,
освобождение ре-
сурсов
24
Таблица 5: Вспомогательные функции системы
№ Прототип
функции
Входные
параметры
Выходной
Описание функ-
пара-
метр
ционала
14 int
getNextNoteId()
– int Генерация следую-
щего уникального
идентификатора
для новой заметки
15 std::string
getCurrentDate()
– std::string Получение текущей
даты в формате
ГГГГ-ММ-ДД для
создания заметки
16 std::string
note - струк-
generateFilePath(const
тура заметки
Note& note)
std::string Генерация пути к
файлу на основе ID
и названия заметки
17 bool
message -
confirmAction(const
текст под-
std::string&
тверждения
message)
bool (ре-
зультат)
Запрос подтвер-
ждения действия у
пользователя с за-
данным сообщением
18 void
clearScreen()
– – Очисткаэкранакон-
соли для улучше-
ния читаемости ин-
терфейса
7.4 Структура проекта
Проект организован в виде нескольких файлов для улучшения читаемости
и поддерживаемости кода:
note_system/
main.cpp # Точка входа, главная функция
note.h # Заголовочный файл с объявлениями структур
note.cpp # Реализация работы с заметками
file_handler.h # Заголовочный файл для операций с файлами
file_handler.cpp # Реализация файловых операций
25
ui.h Makefile # Заголовочный файл пользовательского интерфейса
ui.cpp # Реализация пользовательского интерфейса
# Файл для сборки проекта
7.5 Реализация ключевых алгоритмов
7.5.1 Алгоритм загрузки данных
std::vector<Note> FileHandler::loadAllNotes()
{
std::vector<Note> notes;
std::ifstream file(METADATA_FILE);
if (!file.is_open()) {
return notes; // Возвращаем пустой вектор
}
std::string line;
while (std::getline(file, line)) {
Note note = parseMetadataLine(line);
if (validateNote(note)) {
notes.push_back(note);
}
}
file.close();
return notes;
}
7.5.2 Алгоритм поиска по теме
std::vector<Note> searchNotesByCategory(
const std::vector<Note>& notes,
const std::string& category)
{
std::vector<Note> result;
26
for (const auto& note : notes) {
if (note.category == category) {
result.push_back(note);
}
}
// Сортировка результатов по дате создания
std::sort(result.begin(), result.end(),
[](const Note& a, const Note& b) {
return a.creationDate > b.creationDate;
});
return result;
}
7.5.3 Алгоритм валидации ввода
bool validateNoteTitle(const std::string& title)
{
// Проверка длины
if (title.empty() || title.length() > 100) {
return false;
}
// Проверка допустимых символов
for (char c : title) {
if (!std::isalnum(c) && c != ’ ’ && c != ’-’ && c != ’_’) {
return false;
}
}
return true;
}
27
7.6 Использованные приемы оптимизации
7.6.1 Оптимизация производительности
• Кэширование данных:Заметки загружаются в память при старте
программы для уменьшения количества файловых операций
• Эффективные алгоритмы: Использование стандартных алгорит-
мов STL (std::sort, std::find)
• Оптимизация памяти: Использование ссылок для передачи боль-
ших объектов
7.6.2 Оптимизация объема кода
• Повторное использование: Выделение общих функций в отдель-
ные модули
• Шаблонные функции: Создание универсальных функций для ра-
боты с различными типами данных
• Стандартная библиотека: Активное использование возможностей
STL
7.7 Использованные средства отладки
В процессе разработки применялись следующие инструменты отладки:
7.7.1 Средства компилятора
• Предупреждениякомпилятора:Включенмаксимальныйуровень
предупреждений (-Wall -Wextra)
• Отладочная информация:Компиляция с отладочной информаци-
ей (-g)
• Статический анализ: Использование инструментов для проверки
стиля кода
7.7.2 Техники отладки
• Логирование: Добавление отладочных сообщений для отслежива-
ния выполнения программы
28
• Пошаговое выполнение: Использование отладчика для анализа
состояния программы
• Тестовые данные: Создание тестовых наборов данных для провер-
ки краевых случаев
7.7.3 Обработка ошибок
void FileHandler::saveNoteToFile(const Note& note)
{
std::ofstream file(note.filePath);
if (!file.is_open()) {
throw std::runtime_error(
"Ошибка: невозможно создать файл " + note.filePath);
}
try {
file << "Название: " << note.title << "\n";
file << "Тема: " << note.category << "\n";
file << "Дата: " << note.creationDate << "\n\n";
file << note.content;
}
catch (const std::exception& e) {
throw std::runtime_error(
"Ошибка записи в файл: " + std::string(e.what()));
}
file.close();
}
7.8 Особенности реализации
7.8.1 Обработка исключительных ситуаций
Программа предусматривает обработку следующих исключительных ситу-
аций:
29
• Отсутствие файлов данных при первом запуске
• Повреждение файлов метаданных
• Недостаток дискового пространства
• Некорректный ввод пользователя
7.8.2 Кроссплатформенность
Для обеспечения кроссплатформенности использованы:
• Стандартная библиотека C++ без платформо-зависимых вызовов
• Относительные пути к файлам
• Кодировка UTF-8 для поддержки русского языка
7.8.3 Безопасность
• Проверка всех вводимых пользователем данных
• Валидация путей к файлам для предотвращения инъекций
• Ограничение максимального размера вводимых данных
30
