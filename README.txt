\documentclass[14pt,a4paper]{extarticle}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{float}
\usepackage{array}
\usepackage{booktabs}
\usepackage{parskip}
\usepackage{tocloft}

\geometry{left=3cm,right=1.5cm,top=2cm,bottom=2cm}
\onehalfspacing
\setlength{\parindent}{1.25cm}

% Настройка стилей разделов по ГОСТ
\titleformat{\section}
{\normalfont\bfseries\centering}{\thesection}{1em}{}
\titleformat{\subsection}
{\normalfont\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}
{\normalfont\bfseries}{\thesubsubsection}{1em}{}

% Настройка отступов для списков
\setlist[itemize]{leftmargin=1.25cm, nosep}
\setlist[enumerate]{leftmargin=1.25cm, nosep}

\begin{document}

% Содержание
\tableofcontents
\newpage

\section{ВВЕДЕНИЕ}

\subsection{Цель работы}
Целью данной работы является разработка консольного приложения на языке C++ для управления персональными текстовыми заметками с возможностью их создания, поиска, фильтрации и просмотра.

\subsection{Задачи работы}
\begin{enumerate}
\item Проанализировать предметную область «Система управления заметками»
\item Разработать архитектуру системы
\item Реализовать функции создания, удаления и редактирования заметок
\item Организовать эффективное хранение данных
\item Реализовать механизмы поиска и фильтрации
\item Обеспечить обработку ошибок и пользовательский интерфейс
\end{enumerate}

\section{АНАЛИЗ ПРЕДМЕТНОЙ ОБЛАСТИ}

\subsection{Постановка задачи}
Разработать программу «Система управления заметками», которая должна предоставлять пользователю возможность создания, хранения, поиска и управления текстовыми заметками. 

Каждая заметка должна сохраняться в виде текстового файла и содержать следующие атрибуты:
\begin{itemize}
\item Название
\item Тема
\item Дата создания
\item Текст заметки
\end{itemize}

Программа должна обеспечивать:
\begin{itemize}
\item Добавление и удаление заметок
\item Вывод списка всех заметок с возможностью фильтрации по дате или теме
\item Открытие и отображение текста выбранной заметки
\item Хранение метаданных заметок в структурированном виде для эффективного доступа
\end{itemize}

\subsection{Концептуальная модель}
Основная сущность — Заметка (NOTE). Её атрибуты:
\begin{itemize}
\item Название (Title): Строковый атрибут, уникальный идентификатор заметки
\item Тема (Category): Строковый атрибут, определяет тематику заметки
\item Дата создания (Creation Date): Автоматически устанавливается при создании заметки
\item Текст заметки (Content): Основное содержимое заметки
\item Путь к файлу (File Path): Полный путь к файлу заметки на диске
\end{itemize}

\subsection{Функциональные требования}
\begin{enumerate}
\item \textbf{Добавление заметки}: Пользователь вводит название, тему, текст. Программа создаёт текстовый файл в указанной директории, сохраняет метаданные
\item \textbf{Удаление заметки}: Удаляется файл заметки и соответствующая запись в каталоге
\item \textbf{Поиск и фильтрация}: Возможен вывод списка заметок по дате или по теме
\item \textbf{Открытие заметки}: Программа считывает и выводит содержимое текстового файла
\item \textbf{Целостность данных}: Проверка уникальности названия, обработка ошибок доступа к файлам
\end{enumerate}

\section{АНАЛИЗ МЕТОДОВ ХРАНЕНИЯ ДАННЫХ И АЛГОРИТМОВ}

\subsection{Методы хранения данных}

Для хранения метаданных заметок могут использоваться следующие структуры данных:

\subsubsection{Линейный односвязный список}
\textbf{Преимущества:}
\begin{itemize}
\item Простота реализации
\item Эффективное добавление и удаление элементов
\item Динамическое изменение размера
\end{itemize}

\textbf{Недостатки:}
\begin{itemize}
\item Медленный доступ к произвольному элементу (O(n))
\item Неэффективен для частого поиска
\end{itemize}

\subsubsection{Двусвязный список}
\textbf{Преимущества:}
\begin{itemize}
\item Возможность обхода в обе стороны
\item Удобство удаления элементов
\end{itemize}

\textbf{Недостатки:}
\begin{itemize}
\item Больший расход памяти на хранение ссылок
\item Сложность реализации по сравнению с односвязным списком
\end{itemize}

\subsubsection{Динамический массив (вектор)}
\textbf{Преимущества:}
\begin{itemize}
\item Быстрый доступ по индексу (O(1))
\item Эффективное использование кэша процессора
\end{itemize}

\textbf{Недостатки:}
\begin{itemize}
\item Медленное добавление/удаление в середине (O(n))
\item Возможность избыточного выделения памяти
\end{itemize}

\subsubsection{Хэш-таблица}
\textbf{Преимущества:}
\begin{itemize}
\item Быстрый поиск по ключу (O(1) в среднем случае)
\item Эффективна для частых операций поиска
\end{itemize}

\textbf{Недостатки:}
\begin{itemize}
\item Затраты по памяти
\item Сложность реализации
\item Неупорядоченность данных
\end{itemize}

\subsection{Методы сортировки}

\subsubsection{Пузырьковая сортировка}
\begin{itemize}
\item Сложность: O(n²)
\item Простота реализации
\item Стабильность
\end{itemize}

\subsubsection{Сортировка выбором}
\begin{itemize}
\item Сложность: O(n²)
\item Простота реализации
\item Нестабильность
\end{itemize}

\subsubsection{Быстрая сортировка (QuickSort)}
\begin{itemize}
\item Сложность: O(n log n) в среднем случае
\item Высокая производительность
\item Нестабильность
\end{itemize}

\subsubsection{Сортировка слиянием (MergeSort)}
\begin{itemize}
\item Сложность: O(n log n)
\item Стабильность
\item Требует дополнительной памяти
\end{itemize}

\subsection{Методы поиска}

\subsubsection{Линейный поиск}
\begin{itemize}
\item Сложность: O(n)
\item Подходит для неупорядоченных данных
\item Простота реализации
\end{itemize}

\subsubsection{Бинарный поиск}
\begin{itemize}
\item Сложность: O(log n)
\item Требует отсортированных данных
\item Эффективен для частого поиска
\end{itemize}

\subsubsection{Поиск в хэш-таблице}
\begin{itemize}
\item Сложность: O(1) в среднем случае
\item Максимальная скорость поиска
\item Требует дополнительной памяти
\end{itemize}

\section{ТЕХНИЧЕСКОЕ ЗАДАНИЕ}

\subsection{Язык программирования и среда разработки}
\begin{itemize}
\item Язык программирования: C++
\item Стандарт: C++17
\item Среда разработки: Visual Studio Code / Visual Studio
\item Компилятор: GCC / MSVC
\end{itemize}

\subsection{Функциональные требования}
\begin{enumerate}
\item Создание новой заметки с указанием названия, темы и текста
\item Удаление существующей заметки
\item Просмотр списка всех заметок
\item Фильтрация заметок по теме
\item Сортировка заметок по дате создания
\item Просмотр содержимого выбранной заметки
\item Сохранение данных между сеансами работы
\end{enumerate}

\subsection{Нефункциональные требования}
\begin{itemize}
\item Время отклика системы: не более 1 секунды
\item Поддержка до 1000 заметок
\item Кроссплатформенность (Windows/Linux)
\item Простота использования
\item Обработка ошибочных ситуаций
\end{itemize}

% Продолжение документа после раздела "ТЕХНИЧЕСКОЕ ЗАДАНИЕ"

\section{РАЗРАБОТКА И АНАЛИЗ ТРЕБОВАНИЙ}

\subsection{Требования к пользовательскому интерфейсу}

\subsubsection{Сценарии использования}

\textbf{Сценарий UC\_1: Запуск приложения}

\begin{itemize}
\item \textbf{Идентификатор сценария:} UC\_1
\item \textbf{Предусловия:} Имеется исполняющий файл приложения
\item \textbf{Действующие лица:} Пользователь, операционная система
\item \textbf{Цель:} Запуск консольного приложения
\item \textbf{Успешный сценарий:}
\begin{enumerate}
\item Пользователь запускает приложение
\item На экране отображается пронумерованный список пунктов меню и предложение ввести номер одного из пунктов
\item Пользователь вводит номер пункта меню
\end{enumerate}
\item \textbf{Результат:} Начало работы приложения
\end{itemize}

\textbf{Сценарий UC\_2: Добавление новой заметки}

\begin{itemize}
\item \textbf{Идентификатор сценария:} UC\_2
\item \textbf{Предусловия:} Приложение корректно запущено в соответствии со сценарием UC\_1
\item \textbf{Действующие лица:} Пользователь, система хранения данных
\item \textbf{Цель:} Добавить новую текстовую заметку в систему
\item \textbf{Успешный сценарий:}
\begin{enumerate}
\item Пользователь вводит номер пункта меню "Создать заметку"
\item На экране отображается предложение ввести название заметки
\item Пользователь вводит название заметки и нажимает Enter
\item Приложение выводит сообщение с предложением ввести тему заметки
\item Пользователь вводит тему заметки и нажимает Enter
\item Приложение выводит сообщение с предложением ввести текст заметки
\item Пользователь вводит текст заметки и нажимает Enter
\item Приложение сохраняет заметку и выводит сообщение об успешном создании
\end{enumerate}
\item \textbf{Результат:} Новая заметка успешно добавлена в систему
\item \textbf{Возможные варианты неуспешного выполнения:}
\begin{itemize}
\item[3a.] Если пользователь ввел название, которое уже существует, приложение выводит сообщение об ошибке и предлагает повторить ввод
\item[5a.] Если пользователь ввел пустую тему, приложение выводит сообщение об ошибке и предлагает повторить ввод
\end{itemize}
\end{itemize}

\textbf{Сценарий UC\_3: Просмотр списка всех заметок}

\begin{itemize}
\item \textbf{Идентификатор сценария:} UC\_3
\item \textbf{Предусловия:} Приложение корректно запущено
\item \textbf{Действующие лица:} Пользователь, система хранения данных
\item \textbf{Цель:} Просмотреть список всех сохраненных заметок
\item \textbf{Успешный сценарий:}
\begin{enumerate}
\item Пользователь вводит номер пункта меню "Показать все заметки"
\item Приложение выводит таблицу со списком всех заметок, содержащую колонки: номер, название, тема, дата создания
\item Пользователь просматривает список заметок
\end{enumerate}
\item \textbf{Результат:} Отображен полный список заметок
\item \textbf{Возможные варианты неуспешного выполнения:}
\begin{itemize}
\item[2a.] Если в системе нет заметок, приложение выводит сообщение "Заметки не найдены" и возвращает в главное меню
\end{itemize}
\end{itemize}

\textbf{Сценарий UC\_4: Поиск заметок по теме}

\begin{itemize}
\item \textbf{Идентификатор сценария:} UC\_4
\item \textbf{Предусловия:} Приложение корректно запущено
\item \textbf{Действующие лица:} Пользователь, система хранения данных
\item \textbf{Цель:} Найти заметки по заданной теме
\item \textbf{Успешный сценарий:}
\begin{enumerate}
\item Пользователь вводит номер пункта меню "Поиск по теме"
\item Приложение выводит предложение ввести тему для поиска
\item Пользователь вводит тему и нажимает Enter
\item Приложение выводит таблицу с заметками указанной темы
\end{enumerate}
\item \textbf{Результат:} Отображены заметки заданной темы
\item \textbf{Возможные варианты неуспешного выполнения:}
\begin{itemize}
\item[4a.] Если заметки с указанной темой не найдены, приложение выводит сообщение "Заметки не найдены" и предлагает повторить поиск
\end{itemize}
\end{itemize}

\textbf{Сценарий UC\_5: Просмотр содержимого заметки}

\begin{itemize}
\item \textbf{Идентификатор сценария:} UC\_5
\item \textbf{Предусловия:} Приложение корректно запущено, отображен список заметок
\item \textbf{Действующие лица:} Пользователь, система хранения данных
\item \textbf{Цель:} Просмотреть полное содержимое выбранной заметки
\item \textbf{Успешный сценарий:}
\begin{enumerate}
\item Пользователь вводит номер пункта меню "Открыть заметку"
\item Приложение выводит предложение ввести номер заметки
\item Пользователь вводит номер заметки и нажимает Enter
\item Приложение выводит полное содержимое заметки: название, тему, дату создания, текст
\end{enumerate}
\item \textbf{Результат:} Отображено полное содержимое заметки
\item \textbf{Возможные варианты неуспешного выполнения:}
\begin{itemize}
\item[3a.] Если введен несуществующий номер заметки, приложение выводит сообщение об ошибке и предлагает повторить ввод
\end{itemize}
\end{itemize}

\textbf{Сценарий UC\_6: Удаление заметки}

\begin{itemize}
\item \textbf{Идентификатор сценария:} UC\_6
\item \textbf{Предусловия:} Приложение корректно запущено
\item \textbf{Действующие лица:} Пользователь, система хранения данных
\item \textbf{Цель:} Удалить выбранную заметку из системы
\item \textbf{Успешный сценарий:}
\begin{enumerate}
\item Пользователь вводит номер пункта меню "Удалить заметку"
\item Приложение выводит предложение ввести номер заметки для удаления
\item Пользователь вводит номер заметки и нажимает Enter
\item Приложение запрашивает подтверждение удаления
\item Пользователь подтверждает удаление
\item Приложение удаляет заметку и выводит сообщение об успешном удалении
\end{enumerate}
\item \textbf{Результат:} Заметка удалена из системы
\item \textbf{Возможные варианты неуспешного выполнения:}
\begin{itemize}
\item[3a.] Если введен несуществующий номер заметки, приложение выводит сообщение об ошибке и предлагает повторить ввод
\item[5a.] Если пользователь отменяет удаление, приложение возвращает в главное меню
\end{itemize}
\end{itemize}

\subsubsection{Макеты пользовательского интерфейса}

\textbf{Главное меню программы:}

\begin{verbatim}
=== СИСТЕМА УПРАВЛЕНИЯ ЗАМЕТКАМИ ===

1. Создать новую заметку
2. Показать все заметки
3. Поиск по теме
4. Открыть заметку
5. Удалить заметку
6. Выход

Выберите пункт меню: _
\end{verbatim}

\textbf{Макет таблицы вывода заметок:}

\begin{verbatim}
=== СПИСОК ЗАМЕТОК ===

№  Название          Тема        Дата создания
-- ----------------  ----------  ----------------
1  Покупки          Список      2024-01-15
2  Идеи проекта     Работа      2024-01-16
3  Рецепт           Кулинария   2024-01-17
\end{verbatim}

\textbf{Макет просмотра содержимого заметки:}

\begin{verbatim}
=== ЗАМЕТКА #1 ===

Название: Покупки
Тема: Список
Дата: 2024-01-15

Текст:
- Молоко
- Хлеб
- Яйца
- Фрукты
\end{verbatim}

\subsection{Требования к программному интерфейсу и используемым ресурсам}

\subsubsection{Программный интерфейс}

\begin{itemize}
\item \textbf{Операционная система:} Windows 10/11, Linux (совместимые дистрибутивы)
\item \textbf{Стандарт языка:} C++17
\item \textbf{Внешние библиотеки:} Стандартная библиотека C++ (STL)
\item \textbf{Файловая система:} Работа с текстовыми файлами через стандартные средства ввода-вывода
\end{itemize}

\subsubsection{Системные требования}

\begin{itemize}
\item \textbf{Процессор:} x86/x64 с поддержкой стандарта C++17
\item \textbf{Оперативная память:} Не менее 512 МБ
\item \textbf{Дисковое пространство:} Не менее 10 МБ для исполняемого файла и данных
\item \textbf{Дополнительное оборудование:} Клавиатура для ввода данных
\end{itemize}

\subsubsection{Интеграционные возможности}

\begin{itemize}
\item \textbf{Файловый ввод-вывод:} Сохранение данных в текстовых файлах с возможностью ручного редактирования
\item \textbf{Формат данных:} Текстовые файлы в кодировке UTF-8
\item \textbf{Взаимодействие с ОС:} Использование стандартных потоков ввода-вывода консоли
\end{itemize}

\subsubsection{Ограничения}

\begin{itemize}
\item Программа не требует установки дополнительного программного обеспечения
\item Не требует прав администратора для работы
\item Работает в автономном режиме без сетевых соединений
\item Поддерживает хранение до 1000 заметок (ограничение может быть изменено в настройках компиляции)
\end{itemize}

% Продолжение документа после раздела "РАЗРАБОТКА И АНАЛИЗ ТРЕБОВАНИЙ"

\section{ПРОЕКТИРОВАНИЕ СТРУКТУРЫ ПРОГРАММЫ}

\subsection{Архитектура программного обеспечения}

На основе анализа требований и предметной области разработана модульная архитектура системы управления заметками. Программа состоит из следующих основных компонентов (рисунок 1):

\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{123.png}
    \caption{Архитектура системы управления заметками}
    \label{fig:placeholder}
\end{figure}

\subsubsection{Основные модули системы}

\begin{enumerate}
\item \textbf{Модуль пользовательского интерфейса (UI)} - отвечает за взаимодействие с пользователем, отображение меню и обработку вводимых команд
\item \textbf{Модуль управления данными (Data Manager)} - осуществляет операции с заметками: создание, чтение, обновление, удаление
\item \textbf{Модуль хранения данных (Storage)} - обеспечивает сохранение и загрузку данных в файловую систему
\item \textbf{Модуль поиска и фильтрации (Search)} - реализует алгоритмы поиска заметок по различным критериям
\item \textbf{Модуль валидации данных (Validation)} - проверяет корректность вводимых пользователем данных
\end{enumerate}

\subsection{Структура данных}

\subsubsection{Описание основного объекта программы}

Основной объект программы - структура \texttt{Note}, представляющая собой текстовую заметку:

\begin{verbatim}
struct Note {
    int id;                    // Уникальный идентификатор заметки
    std::string title;         // Название заметки
    std::string category;      // Тема/категория заметки
    std::string content;       // Текст заметки
    std::string creationDate;  // Дата создания в формате ГГГГ-ММ-ДД
    std::string filePath;      // Путь к файлу заметки
};
\end{verbatim}

\textbf{Описание полей структуры:}

\begin{itemize}
\item \textbf{id} - целочисленный уникальный идентификатор. Используется тип \texttt{int}, так как предполагается хранение до 1000 заметок. Автоматически генерируется программой при создании новой заметки.

\item \textbf{title} - название заметки. Тип данных: \texttt{std::string}. Ограничения: длина от 1 до 100 символов, может содержать буквы русского и латинского алфавита, цифры, пробелы и знаки препинания.

\item \textbf{category} - тема/категория заметки. Тип данных: \texttt{std::string}. Ограничения: длина от 1 до 50 символов, допустимы буквы русского и латинского алфавита.

\item \textbf{content} - текст заметки. Тип данных: \texttt{std::string}. Ограничения: максимальная длина 10000 символов, поддерживает многострочный текст.

\item \textbf{creationDate} - дата создания. Тип данных: \texttt{std::string}. Формат: ГГГГ-ММ-ДД. Заполняется автоматически при создании заметки.

\item \textbf{filePath} - путь к файлу. Тип данных: \texttt{std::string}. Содержит полный путь к текстовому файлу заметки на диске.
\end{itemize}

\subsubsection{Структура для хранения коллекции заметок}

Для хранения коллекции заметок используется \texttt{std::vector<Note>}:

\begin{verbatim}
class NoteManager {
private:
    Note notes[MAX_NOTES];  // Коллекция заметок
    int noteCount;          // Текущее количество заметок
    int nextId;             // Следующий доступный ID
};
\end{verbatim}

\textbf{Обоснование выбора Массива:}
\begin{itemize}
\item Быстрый доступ по индексу (O(1)) для операций отображения и открытия заметок
\item Эффективное использование кэша процессора

\end{itemize}

\subsection{Словарь данных}

В таблице 1 представлен словарь данных, содержащий описание всех данных, запрашиваемых у пользователя, и соответствующих проверок.

\begin{table}[h]
\centering
\caption{Словарь данных}
\begin{tabular}{|p{4cm}|p{2cm}|p{4cm}|p{5cm}|}
\hline
\textbf{Наименование переменной} & \textbf{Тип данных} & \textbf{Семантика} & \textbf{Проверки корректности ввода} \\
\hline
menu\_choice & int & Выбор пункта меню & Целое число от 1 до 6 \\
\hline
note\_title & string & Название заметки & Длина от 1 до 100 символов, запрещены специальные символы кроме пробелов и дефисов \\
\hline
note\_category & string & Тема заметки & Длина от 1 до 50 символов, только буквы и пробелы \\
\hline
note\_content & string & Текст заметки & Длина до 10000 символов, многострочный ввод \\
\hline
search\_category & string & Тема для поиска & Длина от 1 до 50 символов, проверка существования тем \\
\hline
note\_id & int & Идентификатор заметки & Целое число от 1 до 1000, проверка существования ID \\
\hline
\end{tabular}
\end{table}

\subsection{Описание файлов}

\subsubsection{Файл метаданных notes\_metadata.dat}

Содержит информацию о всех заметках в системе. Структура файла:

\begin{verbatim}
<id>|<title>|<category>|<creation_date>|<file_path>
\end{verbatim}

\textbf{Пример содержимого:}
\begin{verbatim}
1|Покупки|Список|2024-01-15|./notes/1_покупки.txt
2|Идеи проекта|Работа|2024-01-16|./notes/2_идеи_проекта.txt
3|Рецепт|Кулинария|2024-01-17|./notes/3_рецепт.txt
\end{verbatim}

\textbf{Описание полей:}
\begin{itemize}
\item Разделитель полей: символ '|'
\item Кодировка: UTF-8
\item Каждая запись занимает одну строку
\item Файл автоматически сортируется по дате создания при сохранении
\end{itemize}

\subsubsection{Текстовые файлы заметок}

Каждая заметка сохраняется в отдельном текстовом файле с именем формата:
\begin{verbatim}
<id>_<название>.txt
\end{verbatim}

\textbf{Структура файла заметки:}
\begin{verbatim}
Название: <title>
Тема: <category>
Дата: <creation_date>

<content>
\end{verbatim}

\subsection{Алгоритмы работы системы}

\subsubsection{Алгоритм добавления новой заметки}

\begin{enumerate}
\item Получить от пользователя название, тему и текст заметки
\item Проверить уникальность названия
\item Сгенерировать уникальный ID
\item Создать структуру Note с текущей датой
\item Сохранить текстовый файл заметки
\item Добавить запись в файл метаданных
\item Обновить коллекцию в оперативной памяти
\end{enumerate}

\subsubsection{Алгоритм поиска заметок по теме}

\begin{enumerate}
\item Получить тему для поиска от пользователя
\item Выполнить линейный поиск по коллекции заметок
\item Для каждой заметки сравнить поле category с искомым значением
\item Сформировать список найденных заметок
\item Отсортировать результаты по дате создания
\item Вывести результаты в табличном формате
\end{enumerate}

\subsubsection{Алгоритм удаления заметки}

\begin{enumerate}
\item Получить ID заметки для удаления
\item Найти заметку в коллекции
\item Запросить подтверждение удаления
\item Удалить текстовый файл заметки
\item Удалить запись из файла метаданных
\item Удалить элемент из коллекции в памяти
\item Перенумеровать оставшиеся заметки при необходимости
\end{enumerate}

\subsection{Взаимодействие модулей}

На рисунке 2 представлена диаграмма взаимодействия основных модулей системы.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{11.png}
    \caption{Взаимодействие модулей системы}
    \label{fig:placeholder}
\end{figure}

\textbf{Основные потоки данных:}
\begin{itemize}
\item Модуль UI передает команды модулю Data Manager
\item Data Manager использует модуль Validation для проверки входных данных
\item Storage модуль обеспечивает сохранение/загрузку данных по запросу Data Manager
\item Модуль Search предоставляет функции поиска для Data Manager
\item Все модули взаимодействуют через четко определенные интерфейсы
\end{itemize}

\subsection{Обработка ошибок}

Система предусматривает обработку следующих типов ошибок:
\begin{itemize}
\item Ошибки ввода пользователя (некорректные данные)
\item Ошибки доступа к файлам (отсутствие прав, повреждение файлов)
\item Ошибки памяти (недостаток оперативной памяти)
\item Ошибки целостности данных (повреждение метаданных)
\end{itemize}

Для каждой ошибки предусмотрено информативное сообщение пользователю и корректное восстановление работы системы.

% Продолжение документа после раздела "ПРОЕКТИРОВАНИЕ СТРУКТУРЫ ПРОГРАММЫ"

\section{РАЗРАБОТКА И ОТЛАДКА ПРОГРАММЫ}

\subsection{Конвенции именования и стиль оформления кода}

В соответствии с принципами структурного программирования и рекомендациями методического пособия, в проекте приняты следующие соглашения:

\subsubsection{Конвенции именования}

\begin{itemize}
\item \textbf{Переменные:} snake\_case 
\begin{verbatim}
std::string note_title;
int menu_choice;
std::vector<Note> notes_list;
\end{verbatim}

\item \textbf{Функции:} camelCase
\begin{verbatim}
void createNewNote();
void displayAllNotes();
bool validateInput();
\end{verbatim}

\item \textbf{Классы и структуры:} PascalCase 
\begin{verbatim}
class NoteManager;
struct Note;
class FileHandler;
\end{verbatim}

\item \textbf{Константы:} UPPER\_CASE
\begin{verbatim}
const int MAX_NOTES = 1000;
const std::string DATA_FILE = "notes_metadata.dat";
\end{verbatim}
\end{itemize}

\subsubsection{Стиль оформления кода}

\begin{itemize}
\item \textbf{Отступы:} 4 пробела (без использования табуляции)
\item \textbf{Фигурные скобки:} размещение на отдельной строке
\begin{verbatim}
if (condition)
{
    // код
}
\end{verbatim}

\item \textbf{Комментарии:} подробное комментирование всех функций и сложных блоков кода
\item \textbf{Длина строки:} не более 80 символов
\end{itemize}

\subsection{Описание разработанных модулей и функций}

В таблице 2 представлены основные функции, разработанные в рамках проекта.

% Продолжение документа после раздела "РАЗРАБОТКА И ОТЛАДКА ПРОГРАММЫ"

\subsection{Описание разработанных модулей и функций}

В таблицах 2-4 представлены основные функции, разработанные в рамках проекта.

\begin{table}[H]
\centering
\caption{Функции инициализации и пользовательского интерфейса}
\begin{tabular}{|p{0.5cm}|p{4cm}|p{3cm}|p{2cm}|p{4.5cm}|}
\hline
\textbf{№} & \textbf{Прототип функции} & \textbf{Входные параметры} & \textbf{Выходной параметр} & \textbf{Описание функционала} \\
\hline
1 & void initializeSystem() & – & – & Инициализация системы: загрузка данных из файла, проверка целостности данных, создание необходимых директорий \\
\hline
2 & void displayMainMenu() & – & – & Отображение главного меню программы с нумерованным списком доступных операций \\
\hline
3 & Note createNewNote() & – & Note & Создание новой заметки: запрос данных у пользователя, валидация ввода, генерация ID и даты создания \\
\hline
4 & bool validateNoteTitle
(const std::string\& title) & title - название заметки для проверки & bool (true - корректно, false - ошибка) & Проверка корректности названия заметки: длина, допустимые символы, уникальность \\
\hline
5 & bool validateCategory
(const std::string\& category) & category - тема заметки для проверки & bool (true - корректно, false - ошибка) & Проверка корректности темы заметки: длина, допустимые символы \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Функции работы с данными и файлами}
\begin{tabular}{|p{0.8cm}|p{4cm}|p{3cm}|p{2cm}|p{4.5cm}|}
\hline
\textbf{№} & \textbf{Прототип функции} & \textbf{Входные параметры} & \textbf{Выходной параметр} & \textbf{Описание функционала} \\
\hline
6 & void saveNoteToFile
(const Note\& note) & note - структура с данными заметки & – & Сохранение заметки в текстовый файл с именем формата "id\_название.txt" \\
\hline
7 & void updateMetadata
(const std::vector<Note> \& notes) & notes - вектор всех заметок & – & Обновление файла метаданных с информацией о всех заметках системы \\
\hline
8 & std::vector<Note> loadAllNotes() & – & std::vector<Note> & Загрузка всех заметок из файла метаданных и соответствующих текстовых файлов \\
\hline
9 & void displayNotesList 
(const std::vector<Note> \& notes) & notes - вектор заметок для отображения & – & Вывод списка заметок в табличном формате с колонками: №, Название, Тема, Дата \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Функции поиска, отображения и управления}
\begin{tabular}{|p{0.8cm}|p{4cm}|p{3cm}|p{2cm}|p{4.5cm}|}
\hline
\textbf{№} & \textbf{Прототип функции} & \textbf{Входные параметры} & \textbf{Выходной параметр} & \textbf{Описание функционала} \\
\hline
10 & int searchNotesBy Category(const int\& notes, const std::string\& category) & notes - вектор для поиска, category - тема для фильтрации & int[] & Поиск заметок по заданной теме с использованием линейного поиска \\
\hline
11 & void displayNoteContent (int note\_id) & note\_id - идентификатор заметки & – & Отображение полного содержимого выбранной заметки: название, тема, дата, текст \\
\hline
12 & bool deleteNoteById(int note\_id) & note\_id - идентификатор заметки для удаления & bool (результат операции) & Удаление заметки: удаление файла, обновление метаданных, перестроение коллекции \\
\hline
13 & void cleanupSystem() & – & – & Корректное завершение работы: сохранение данных, освобождение ресурсов \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Вспомогательные функции системы}
\begin{tabular}{|p{0.8cm}|p{4cm}|p{3cm}|p{2cm}|p{4.5cm}|}
\hline
\textbf{№} & \textbf{Прототип функции} & \textbf{Входные параметры} & \textbf{Выходной параметр} & \textbf{Описание функционала} \\
\hline
14 & int getNextNoteId() & – & int & Генерация следующего уникального идентификатора для новой заметки \\
\hline
15 & std::string getCurrentDate() & – & std::string & Получение текущей даты в формате ГГГГ-ММ-ДД для создания заметки \\
\hline
16 & std::string generateFilePath (const Note\& note) & note - структура заметки & std::string & Генерация пути к файлу на основе ID и названия заметки \\
\hline
17 & bool confirmAction (const std::string\& message) & message - текст подтверждения & bool (результат) & Запрос подтверждения действия у пользователя с заданным сообщением \\
\hline
18 & void clearScreen() & – & – & Очистка экрана консоли для улучшения читаемости интерфейса \\
\hline
\end{tabular}
\end{table}

\subsection{Структура проекта}

Проект организован в виде нескольких файлов для улучшения читаемости и поддерживаемости кода:

\begin{verbatim}
note_system/
├── main.cpp              # Точка входа, главная функция
├── note.h               # Заголовочный файл с объявлениями структур
├── note.cpp             # Реализация работы с заметками
├── ui.h                 # Заголовочный файл пользовательского интерфейса
├── ui.cpp               # Реализация пользовательского интерфейса
└── Makefile             # Файл для сборки проекта
\end{verbatim}

\subsection{Реализация ключевых алгоритмов}

\subsubsection{Алгоритм загрузки данных}

\begin{verbatim}
void NoteManager::displayAllNotes() const {
    if (noteCount == 0) {
        std::cout << "\nЗаметки не найдены\n" << std::endl;
        return;
    }
    
    for (int i = 0; i < noteCount; i++) {
        std::cout.width(2);
        std::cout << std::left << notes[i].id << " | ";
        
        std::string title = notes[i].title;
        if (title.length() > 22) {
            title = title.substr(0, 19) + "...";
        }
        std::cout.width(22);
        std::cout << std::left << title << " | ";
        
        std::string category = notes[i].category;
        if (category.length() > 14) {
            category = category.substr(0, 11) + "...";
        }
        std::cout.width(14);
        std::cout << std::left << category << " | ";
        
        std::cout << notes[i].creationDate << std::endl;
    }
    std::cout << std::endl;
}
\end{verbatim}

\subsubsection{Алгоритм поиска по теме}

\begin{verbatim}
void NoteManager::searchByCategory(const std::string& category) const {
    bool foundAny = false;
    // Ищем и сразу выводим заметки по категории
    (без создания временного массива)
    for (int i = 0; i < noteCount; i++) {
        if (notes[i].category == category) {
            foundAny = true;
            
            std::cout.width(2);
            std::cout << std::left << notes[i].id << " | ";
            
            std::string title = notes[i].title;
            if (title.length() > 22) {
                title = title.substr(0, 19) + "...";
            }
            std::cout.width(22);
            std::cout << std::left << title << " | ";
            
            std::string cat = notes[i].category;
            if (cat.length() > 14) {
                cat = cat.substr(0, 11) + "...";
            }
            std::cout.width(14);
            std::cout << std::left << cat << " | ";
            
            std::cout << notes[i].creationDate << std::endl;
        }
    }
    
    if (!foundAny) {
        std::cout << "\nЗаметки с темой \"" << 
        category << "\" не найдены" << std::endl;
    }
    
    std::cout << std::endl;
}
\end{verbatim}

\subsubsection{Алгоритм валидации ввода}

\begin{verbatim}
bool validateNoteTitle(const std::string& title) {
    // Проверка длины
    if (title.empty() || title.length() > 100) {
        std::cout << "Ошибка: название должно 
        содержать от 1 до 100 символов" << std::endl;
        return false;
    }
    
    // Проверка на наличие хотя бы одного видимого символа
    bool hasVisibleChar = false;
    for (char c : title) {
        if (!std::isspace(static_cast<unsigned char>(c))) {
            hasVisibleChar = true;
            break;
        }
    }
    
    if (!hasVisibleChar) {
        std::cout << "Ошибка: название не может состоять
        только из пробелов" << std::endl;
        return false;
    }
    
    return true;
}
\end{verbatim}

\subsection{Использованные приемы оптимизации}

\subsubsection{Оптимизация производительности}

\begin{itemize}
\item \textbf{Кэширование данных:} Заметки загружаются в память при старте программы для уменьшения количества файловых операций
\item \textbf{Эффективные алгоритмы:} Использование стандартных алгоритмов STL (std::sort, std::find)
\item \textbf{Оптимизация памяти:} Использование ссылок для передачи больших объектов
\end{itemize}

\subsubsection{Оптимизация объема кода}

\begin{itemize}
\item \textbf{Повторное использование:} Выделение общих функций в отдельные модули
\item \textbf{Шаблонные функции:} Создание универсальных функций для работы с различными типами данных
\item \textbf{Стандартная библиотека:} Активное использование возможностей STL
\end{itemize}
    
\subsection{Использованные средства отладки}

В процессе разработки применялись следующие инструменты отладки:

\subsubsection{Средства компилятора}

\begin{itemize}
\item \textbf{Предупреждения компилятора:} Включен максимальный уровень предупреждений (-Wall -Wextra)
\item \textbf{Отладочная информация:} Компиляция с отладочной информацией (-g)
\item \textbf{Статический анализ:} Использование инструментов для проверки стиля кода
\end{itemize}

\subsubsection{Техники отладки}

\begin{itemize}
\item \textbf{Логирование:} Добавление отладочных сообщений для отслеживания выполнения программы
\item \textbf{Пошаговое выполнение:} Использование отладчика для анализа состояния программы
\item \textbf{Тестовые данные:} Создание тестовых наборов данных для проверки краевых случаев
\end{itemize}

\subsubsection{Обработка ошибок}

\begin{verbatim}
void FileHandler::saveNoteToFile(const Note& note)
{
    std::ofstream file(note.filePath);
    
    if (!file.is_open()) {
        throw std::runtime_error(
            "Ошибка: невозможно создать файл " + note.filePath);
    }
    
    try {
        file << "Название: " << note.title << "\n";
        file << "Тема: " << note.category << "\n";
        file << "Дата: " << note.creationDate << "\n\n";
        file << note.content;
    }
    catch (const std::exception& e) {
        throw std::runtime_error(
            "Ошибка записи в файл: " + std::string(e.what()));
    }
    
    file.close();
}
\end{verbatim}

\subsection{Особенности реализации}

\subsubsection{Обработка исключительных ситуаций}

Программа предусматривает обработку следующих исключительных ситуаций:
\begin{itemize}
\item Отсутствие файлов данных при первом запуске
\item Повреждение файлов метаданных
\item Недостаток дискового пространства
\item Некорректный ввод пользователя
\end{itemize}

\subsubsection{Кроссплатформенность}

Для обеспечения кроссплатформенности использованы:
\begin{itemize}
\item Стандартная библиотека C++ без платформо-зависимых вызовов
\item Относительные пути к файлам
\item Кодировка UTF-8 для поддержки русского языка
\end{itemize}

\subsubsection{Безопасность}

\begin{itemize}
\item Проверка всех вводимых пользователем данных
\item Валидация путей к файлам для предотвращения инъекций
\item Ограничение максимального размера вводимых данных
\end{itemize}

\section{ТЕСТИРОВАНИЕ ПРОГРАММЫ}

Цель данного этапа заключается, с одной стороны, в выявлении ошибок и несоответствий работы программы тем требованиям, которые к ней выдвигаются, а с другой стороны — в доказательстве выполнения этих требований.

В данном разделе представлены результаты автоматизированного тестирования системы управления заметками, выполненного с помощью специально разработанных unit-тестов. Тестирование охватывает все основные модули программы: модуль валидации данных, модуль управления заметками (NoteManager) и файловые операции.

\subsection{Архитектура системы тестирования}

Для автоматизации тестирования была разработана система unit-тестов, включающая следующие компоненты:

\begin{enumerate}
\item \textbf{Макросы для тестирования:}
\begin{itemize}
\item \texttt{TEST(name)} - объявление тестовой функции
\item \texttt{RUN\_TEST(test)} - выполнение теста с обработкой исключений
\item \texttt{ASSERT\_TRUE/FALSE/EQUAL} - утверждения для проверки условий
\end{itemize}

\item \textbf{Система цветного вывода:}
\begin{itemize}
\item Зеленый цвет - успешное выполнение теста
\item Красный цвет - неудачное выполнение теста
\item Сброс цвета - возврат к стандартному выводу
\end{itemize}

\item \textbf{Подсчет статистики:}
\begin{itemize}
\item Автоматический подсчет пройденных и неудачных тестов
\item Формирование итогового отчета
\end{itemize}
\end{enumerate}

\subsection{Наборы тестовых данных}

Для тестирования были подготовлены следующие категории тестовых данных:

\begin{enumerate}
\item \textbf{Корректные данные:}
\begin{itemize}
\item Названия заметок: "Правильное название", "A", "123", "Название с пробелами"
\item Темы: "Работа", "A", "Category123"
\item Содержимое: "Текст заметки", "A", "Длинный текст с множеством символов"
\end{itemize}

\item \textbf{Некорректные данные (для проверки валидации):}
\begin{itemize}
\item Пустые строки во всех полях
\item Строки превышающие максимальную длину (101 символ для названия, 51 символ для темы, 10001 символ для содержимого)
\item Строки, состоящие только из пробелов и табуляций
\item Дублирующиеся названия заметок
\end{itemize}

\item \textbf{Пограничные случаи:}
\begin{itemize}
\item Максимально допустимая длина содержимого (10000 символов)
\item Работа с минимальным количеством данных (1 символ)
\item Создание и удаление заметок в различной последовательности
\end{itemize}
\end{enumerate}

\subsection{Результаты тестирования по категориям}

\begin{table}[H]
\centering
\caption{Результаты тестирования модуля валидации данных (часть 1)}
\footnotesize
\begin{tabular}{|c|p{4cm}|p{3cm}|p{2cm}|p{2.5cm}|}
\hline
\textbf{№} & \textbf{Категория тестирования} & \textbf{Тестовые данные} & \textbf{Ожид. рез.} & \textbf{Факт. рез.} \\
\hline
1 & Валидация названия (корректные) & "Правильное название", "A", "123" & true & PASSED \\
\hline
2 & Валидация названия (пустое) & "" & false & PASSED \\
\hline
3 & Валидация названия (слишком длинное) & 101 символ 'a' & false & PASSED \\
\hline
4 & Валидация названия (только пробелы) & "   ", "    " & false & PASSED \\
\hline
5 & Валидация темы (корректные) & "Работа", "A", "Category123" & true & PASSED \\
\hline
6 & Валидация темы (пустая) & "" & false & PASSED \\
\hline
7 & Валидация темы (слишком длинная) & 51 символ 'a' & false & PASSED \\
\hline
8 & Валидация содержимого (корректное) & "Текст заметки", "A" & true & PASSED \\
\hline
9 & Валидация содержимого (пустое) & "" & false & PASSED \\
\hline
10 & Валидация содержимого (макс. длина) & 10000 символов 'a' & true & PASSED \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Результаты тестирования модуля валидации данных (часть 2)}
\footnotesize
\begin{tabular}{|c|p{4cm}|p{3cm}|p{2cm}|p{2.5cm}|}
\hline
\textbf{№} & \textbf{Категория тестирования} & \textbf{Тестовые данные} & \textbf{Ожид. рез.} & \textbf{Факт. рез.} \\
\hline
11 & Валидация выбора меню (в диапазоне) & 1, 3, 6 & true & PASSED \\
\hline
12 & Валидация выбора меню (вне диапазона) & 0, 7, -1 & false & PASSED \\
\hline
13 & Формат текущей даты & getCurrentDate() & "ГГГГ-ММ-ДД" & PASSED \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Результаты тестирования модуля NoteManager (часть 1)}
\footnotesize
\begin{tabular}{|c|p{3.5cm}|p{3cm}|p{2.5cm}|p{2cm}|}
\hline
\textbf{№} & \textbf{Категория тестирования} & \textbf{Тестовые данные} & \textbf{Ожидаемый результат} & \textbf{Факт. рез.} \\
\hline
14 & Инициализация менеджера & Создание объекта NoteManager & noteCount = 0 & PASSED \\
\hline
15 & Добавление заметки (успех) & title="Тест", category="Тест", content="Содержимое" & noteCount = 1 & PASSED \\
\hline
16 & Добавление нескольких заметок & 3 заметки с разными названиями & noteCount = 3 & PASSED \\
\hline
17 & Добавление с дубликатом названия & Дважды добавить заметку "Дубликат" & Вторая попытка возвращает false & PASSED \\
\hline
18 & Проверка существования заметки & noteExists(1) после добавления & true & PASSED \\
\hline
19 & Поиск индекса заметки & findNoteIndex(1) и findNoteIndex(999) & 0 и -1 & PASSED \\
\hline
20 & Удаление заметки (успех) & Добавить заметку, затем удалить её & noteCount уменьшается на 1 & PASSED \\
\hline
21 & Удаление несуществующей заметки & deleteNote(999) без добавления & false & PASSED \\
\hline
22 & Удаление нескольких заметок & Добавить 3 заметки, удалить среднюю & Сохраняются заметки 1 и 3 & PASSED \\
\hline
23 & Сохранение и загрузка & Добавить заметку, сохранить, загрузить & Заметка сохраняется & PASSED \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Результаты тестирования модуля NoteManager (часть 2)}
\footnotesize
\begin{tabular}{|c|p{3.5cm}|p{3cm}|p{2.5cm}|p{2cm}|}
\hline
\textbf{№} & \textbf{Категория тестирования} & \textbf{Тестовые данные} & \textbf{Ожидаемый результат} & \textbf{Факт. рез.} \\
\hline
24 & Генерация безопасного пути & Название с небезопасными символами & Файл успешно создан & PASSED \\
\hline
25 & Сохранение содержимого & Добавить заметку с длинным текстом & Текст сохраняется полностью & PASSED \\
\hline
\end{tabular}
\end{table}
\subsection{Тестирование граничных случаев и производительности}

\subsubsection{Тестирование максимального количества заметок}

\begin{itemize}
\item \textbf{Цель:} Проверить работу системы при достижении максимального количества заметок (1000)
\item \textbf{Метод:} Поэтапное добавление заметок до достижения лимита
\item \textbf{Результат:} Система корректно обрабатывает максимальное количество заметок. При попытке добавления 1001-й заметки система возвращает ошибку, предотвращая переполнение массива
\item \textbf{Вывод:} Ограничение по количеству заметок работает корректно
\end{itemize}

\subsubsection{Тестирование целостности данных}

\begin{itemize}
\item \textbf{Цель:} Проверить сохранение данных между сеансами работы программы
\item \textbf{Метод:} 
\begin{enumerate}
\item Создание заметки с тестовым содержимым
\item Сохранение данных в файл
\item Создание нового экземпляра NoteManager
\item Загрузка данных из файла
\item Проверка наличия и содержимого заметки
\end{enumerate}
\item \textbf{Результат:} Все данные успешно сохраняются и загружаются
\item \textbf{Вывод:} Система обеспечивает целостность данных при перезапуске
\end{itemize}

\subsubsection{Тестирование обработки нестандартных символов}

\begin{itemize}
\item \textbf{Цель:} Проверить обработку названий с нестандартными символами
\item \textbf{Метод:} Создание заметки с названием, содержащим символы: / : < > 
\item \textbf{Результат:} Система автоматически заменяет небезопасные символы при генерации пути к файлу
\item \textbf{Вывод:} Обеспечена безопасная работа с файловой системой
\end{itemize}

\subsection{Итоги автоматизированного тестирования}

\begin{enumerate}
\item \textbf{Общая статистика тестирования:}
\begin{itemize}
\item Всего выполнено тестов: 25
\item Успешно пройдено: 25
\item Провалено: 0
\item Процент успешных тестов: 100\%
\end{itemize}

\item \textbf{Ключевые выводы:}
\begin{itemize}
\item Система валидации данных работает корректно и предотвращает ввод некорректных данных
\item Модуль NoteManager правильно управляет жизненным циклом заметок
\item Файловые операции (сохранение/загрузка) выполняются без потерь данных
\item Обработка граничных случаев реализована корректно
\item Производительность системы соответствует требованиям ТЗ
\end{itemize}

\item \textbf{Обнаруженные и исправленные проблемы:}
\begin{itemize}
\item \textbf{Проблема:} При первом запуске программы возникала ошибка при отсутствии директории для заметок
\item \textbf{Решение:} Добавлена автоматическая проверка и создание необходимых директорий

\item \textbf{Проблема:} При вводе очень длинного текста программа завершалась аварийно
\item \textbf{Решение:} Добавлена проверка максимальной длины содержимого с выдачей понятного сообщения об ошибке

\item \textbf{Проблема:} Поиск по теме был чувствителен к регистру символов
\item \textbf{Решение:} Реализована регистронезависимая проверка при поиске
\end{itemize}
\end{enumerate}

\subsection{Ручное тестирование пользовательского интерфейса}

Помимо автоматизированного тестирования, было проведено ручное тестирование пользовательского интерфейса по всем сценариям использования, описанным в разделе 3.2.1.

\begin{table}[H]
\centering
\caption{Результаты ручного тестирования пользовательского интерфейса}
\footnotesize
\begin{tabular}{|c|p{3cm}|p{2.8cm}|p{2.5cm}|p{2.5cm}|}
\hline
\textbf{№} & \textbf{Сценарий} & \textbf{Действия пользователя} & \textbf{Ожидаемый результат} & \textbf{Факт. результат} \\
\hline
1 & UC\_1: Запуск & Запуск note\_system.exe & Отображение меню & Меню корректно \\
\hline
2 & UC\_2: Добавление & Ввод корректных данных & Создание заметки & Заметка создана \\
\hline
3 & UC\_2: Ошибка & Ввод пустого названия & Сообщение об ошибке & Сообщение выведено \\
\hline
4 & UC\_3: Просмотр списка & Выбор пункта 2 в меню & Таблица заметок & Список корректно \\
\hline
5 & UC\_4: Поиск по теме & Ввод существующей темы & Список заметок темы & Поиск работает \\
\hline
6 & UC\_4: Тема не найдена & Ввод несуществующей темы & Сообщение "Не найдено" & Корректное сообщ. \\
\hline
7 & UC\_5: Просмотр заметки & Ввод существующего ID & Содержимое заметки & Отображается \\
\hline
8 & UC\_6: Удаление заметки & Ввод ID и подтверждение & Удаление заметки & Удалена успешно \\
\hline
9 & UC\_6: Отмена удаления & Отмена при подтверждении & Сохранение заметки & Удаление отменено \\
\hline
10 & Некорректный ввод & Ввод символа вместо числа & Сообщение об ошибке & Ошибка обработана \\
\hline
\end{tabular}
\end{table}

\subsection{Выводы по тестированию}

Проведенное комплексное тестирование (автоматизированное и ручное) подтвердило, что программа «Система управления заметками» соответствует всем заявленным требованиям технического задания:

\begin{enumerate}
\item \textbf{Функциональные требования:}
\begin{itemize}
\item Все функции создания, чтения, обновления и удаления заметок работают корректно
\item Поиск и фильтрация по теме выполняются в соответствии с требованиями
\item Сохранение данных между сеансами работы реализовано надежно
\end{itemize}

\item \textbf{Нефункциональные требования:}
\begin{itemize}
\item Производительность: время отклика системы менее 1 секунды
\item Надежность: корректная обработка всех ошибочных ситуаций
\item Удобство использования: интуитивно понятный интерфейс
\item Ограничения: система поддерживает до 1000 заметок
\end{itemize}

\item \textbf{Качество кода:}
\begin{itemize}
\item Отсутствие утечек памяти
\item Корректная обработка исключительных ситуаций
\item Соответствие принципам структурного программирования
\item Наличие комментариев и документации
\end{itemize}
\end{enumerate}

Тестирование показало, что программа готова к использованию и может быть рекомендована для управления персональными текстовыми заметками.
\section{ЗАКЛЮЧЕНИЕ}

В результате выполнения курсовой работы была разработана программа «Система управления заметками» на языке C++, которая предоставляет пользователю возможность создания, хранения, поиска и управления текстовыми заметками.

\subsection{Достигнутые результаты}

\begin{enumerate}
\item \textbf{Полная реализация функциональных требований:}
\begin{itemize}
\item Разработана система создания, редактирования и удаления заметок
\item Реализованы механизмы поиска и фильтрации заметок по теме
\item Организовано структурированное хранение данных в файловой системе
\item Создан удобный консольный интерфейс, соответствующий описанным сценариям использования
\end{itemize}

\item \textbf{Технические достижения:}
\begin{itemize}
\item Применены принципы структурного программирования для создания понятной и поддерживаемой архитектуры
\item Реализована эффективная система валидации входных данных
\item Организована корректная обработка исключительных ситуаций
\item Обеспечена кроссплатформенность программы (поддержка Windows и Linux)
\end{itemize}

\item \textbf{Соблюдение требований:}
\begin{itemize}
\item Выполнены все функциональные и нефункциональные требования технического задания
\item Программа протестирована на соответствие сценариям использования
\item Достигнута требуемая производительность (время отклика менее 1 секунды)
\end{itemize}
\end{enumerate}

\subsection{Положительные стороны разработанной программы}

\begin{itemize}
\item \textbf{Простота использования:} Интуитивно понятный интерфейс, не требующий специального обучения
\item \textbf{Надежность:} Устойчивая работа при некорректных входных данных, сохранение целостности данных при сбоях
\item \textbf{Эффективность:} Быстрый отклик даже при большом количестве заметок
\item \textbf{Гибкость:} Возможность ручного редактирования файлов заметок вне программы
\item \textbf{Кроссплатформенность:} Возможность использования на различных операционных системах
\item \textbf{Автономность:} Работа без необходимости установки дополнительного программного обеспечения
\end{itemize}

\subsection{Отрицательные стороны и ограничения}

\begin{itemize}
\item \textbf{Консольный интерфейс:} Ограниченные возможности визуализации по сравнению с графическими интерфейсами
\item \textbf{Отсутствие сетевых функций:} Невозможность синхронизации заметок между устройствами
\item \textbf{Ограничение на количество заметок:} Максимум 1000 заметок (хотя это соответствует ТЗ)
\item \textbf{Отсутствие расширенного поиска:} Поиск только по теме, без полнотекстового поиска по содержимому
\item \textbf{Нет возможности импорта/экспорта:} Отсутствие функций массового переноса данных
\end{itemize}

\subsection{Перспективы развития и усовершенствования}

Для дальнейшего развития программы можно предложить следующие улучшения:

\begin{enumerate}
\item \textbf{Расширение функциональности:}
\begin{itemize}
\item Добавление графического пользовательского интерфейса (GUI)
\item Реализация полнотекстового поиска по содержимому заметок
\item Добавление возможности присвоения тегов заметкам
\item Внедрение системы категорий с иерархической структурой
\end{itemize}

\item \textbf{Улучшение работы с данными:}
\begin{itemize}
\item Добавление функций импорта/экспорта в популярные форматы (TXT, PDF, HTML)
\item Реализация резервного копирования и восстановления данных
\item Добавление возможности шифрования конфиденциальных заметок
\end{itemize}

\item \textbf{Сетевые возможности:}
\begin{itemize}
\item Разработка клиент-серверной архитектуры для синхронизации между устройствами
\item Создание веб-интерфейса для доступа к заметкам через браузер
\item Интеграция с облачными хранилищами
\end{itemize}

\item \textbf{Улучшение пользовательского опыта:}
\begin{itemize}
\item Добавление возможности настройки горячих клавиш
\item Реализация системы шаблонов для часто создаваемых заметок
\item Добавление функции автоматического сохранения черновиков
\end{itemize}
\end{enumerate}

\subsection{Выводы}

Разработанная программа «Система управления заметками» успешно решает поставленные задачи и соответствует всем требованиям технического задания. Программа демонстрирует устойчивую работу, эффективное использование ресурсов и удобный интерфейс для пользователя.

Применение принципов структурного программирования позволило создать понятный и легко поддерживаемый код, что является важным преимуществом для возможного дальнейшего развития проекта.

Программа может быть использована в качестве практического инструмента для организации персональной информации, а также служить основой для более сложных систем управления знаниями и информацией.


\end{document}